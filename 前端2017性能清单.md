# 前端2017性能清单

@(前端学习笔记)[前端, 性能]

你已经在使用渐进式启动了吗？那么React 和 Angular中的`tree-shaking`和`code-splitting`呢？你是否设置了 [Brotli](https://zh.wikipedia.org/wiki/Brotli) 或  [Zopfli](https://zh.wikipedia.org/wiki/Zopfli) 压缩,   [OCSP](https://zh.wikipedia.org/wiki/OCSP%E8%A3%85%E8%AE%A2) 封套,  [HPACK](https://http2.github.io/http2-spec/compression.html) 压缩呢？ 那么 [Resource Hints](https://www.keycdn.com/blog/resource-hints/),  [Client Hints](http://httpwg.org/http-extensions/client-hints.html) 和 [CSS Containment ](https://developers.google.com/web/updates/2016/06/css-containment) 呢？就更不用说 IPV6, HTTP/2,  [Server Workers](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 了。

早些时候，性能问题往往都是项目完成之后考虑的。经常被推迟到项目末期，它将会被归结为压缩， 合并， 资源优化以及对服务器的一些配置文件做细微的调整。
现在回头想想， 事情似乎已经发生了很大的变化。

性能并不只是技术上的考量，重要的是，当其融入到工作流当中时，设计理念的往往通过性能的优劣来更好的展现。性能必须持续的测试，监控，优化。日益复杂的 Web 环境给我们带来了新的挑战，我们非常困难去检测具体的性能指标，因为性能指标的检测是非常依赖于终端设备， 浏览器，协议，网络类型以及潜在的一些东西（CDNs， ISPs， 缓存， 代理，防火墙，负载均衡和服务器，它们都在性能问题上扮演非常重要的角色）。

所以，如果我们实际环境中已经涉及到了上述的东西，那么从开始到网站最终的发布提升性能时这些的东西都应该考虑进去。这篇性能清单看上去如何？下面你将会得到一份（希望是公正的客观的）前端2017性能清单——上述问题你可能需要去考虑，以便确保网页响应时间够快，够流畅。

（你也可以下载 [PDF](http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pdf?_ga=1.10326581.1636145688.1482371988) (0129MB) 或者 下载[Apple Pages](http://provide.smashingmagazine.com/performance-checklist/performance-checklist-1.0.pages?_ga=1.9820597.1636145688.1482371988)(0.236MB)）

----------------
[TOC]

微优化对于让性能保持正常状态是很有效的，但是关键是有清晰的目标——可行的目标将影响整个过程中做的任何决定。下面有一些不同的模型，每一个谈论的都是比较之后评价——确保早点设置自己的优先级。

文章提到一些性能指标名词：
1.  start rendering time ：用户在页面上看到的第一个内容的时间
2.   first meaningful paint：页面展示其主要内容所需的时间
3.  time to interactive： 一个页面——主要是单页面应用，加载充分，用户可以与其互动的时间线
4.  


###  准备和设置目标

#### 1. 比你的最快的竞争对手快 20% 。
根据[心理研究](https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/#the-need-for-performance-optimization-the-20-rule)，如果你想要用户感觉你的网站比其他的网站快，你至少需要快 **20%**。
 整页加载时间与像是` start rendering time`( 用户在页面上看到的第一个内容的时间 )等指标不相关，而与[ first meaningful paint](https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint)（即页面展示其主要内容所需的时间）和 [time to interactive](https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive) (即 一个页面——主要是单页面应用，加载充分，用户可以与其互动的时间线) 有关。

在 一部 Moto G ，一部中档三星设备和一部像是 Nexus 4 这样的比较好的中档设备，优先在开放设备实验室（常规的 3G， 4G 和 WIFI）中，测试` start rendering time`（使用 [WebPagetest](http://www.webpagetest.org/)） 和  `first meaningful paint times` （使用 [Lighthouse](https://github.com/GoogleChrome/lighthouse)）。
![enter image description here](https://www.smashingmagazine.com/wp-content/uploads/2016/12/lighthouse_ykpzcd_c_scalew_546-opt.png)

*Lighthouse, a new performance auditing tool by Google.*

查看你的分析数据，了解你的用户的所处的位置，之后你可以测试模拟 90% 的情况。 收集数据，建立一个[spreadsheet](http://danielmall.com/articles/how-to-make-a-performance-budget/), 剔除 20% ，通过这样的方法设定你的目标（即 性能预算）。 现在你有些可以测试的东西。如果你保持预算，尝试压缩脚本，去得到一个比较快的`time-to-interactive` 值，那你就在一个合理的优化路径上。

![Performance budget builder by Brad Frost.](https://www.smashingmagazine.com/wp-content/uploads/2016/12/performance-budget_lbp9l7_c_scalew_1241-opt.png)

*[Performance budget](http://bradfrost.com/blog/post/performance-budget-builder/) builder by Brad Frost.*

与你的同事分享这份清单。确保你的团队的每一位成员都熟悉它，以免带来不必要的误解。如果项目的每一个决策都有性能的考量，那概念，UX和视觉设计方案决定时，项目将会从积极参与的前端开发者上收获巨大。所以，对每一个设计决策，都要考虑性能预算和其在清单中定义的优先级。

#### 2. 100毫秒的响应时间，每秒60帧。
[RAIL性能模型](https://www.smashingmagazine.com/2015/10/rail-user-centric-model-performance/)给我们一些合理的目标：在初始输入之后，反馈时间应尽量少于100毫秒。为了实现小于100毫秒的响应时间，页面必须在50毫秒的时间内让主线程得到控制权。对于像动画一样需要频繁点击的，对于做不到小于100毫秒相应时间的地方，要做绝对的压缩！

而且，动画的每一帧应该在小于16毫秒的时间内完成，从而实现每秒60帧（1 秒 / 60 = 16.6 毫秒），最好小于10毫秒。因为在到达下一个16.6毫秒时间点之前你的代码应该被执行，这样浏览器才有时间去渲染新的帧。客户端应[Be optimistic](http://info.meteor.com/blog/optimistic-ui-with-meteor-latency-compensation)( 个人理解：客户端直接响应用户的交互,在客户端离线对用户行为进行推测 ) 以及聪明的利用空闲的时间。显而易见，这些目标适用于运行性能优化，对于加载性能优化不那么适用。

#### 3.  `First meaningful paint`时间小于1.25秒， SpeedIndex 小于 1000
虽然上面的要求可能很难实现，你的最终目标应该是在良好的网络连接状况下，` start rendering time`小于1秒以及[SpeedIndex](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index)(显示页面的可见部分的平均时间)值应该小于1000。
对于移动端，在3G网络下，一个小于3秒的` start rendering time`才是可以被接受的。稍高于上面指标也是可以的，但是应当尽可能的低。

### 明确环境

#### 4.  选择和设置构建工具
不要太过于关注这段时间感觉很酷的构建工具。构建工具依照于你当前的环境，选择 Grunt, Gulp, Webpack, PostCSS或者是一个组合工具。当你在上面选择中得出结果足够快，在维护构建过程中也没有出现问题的时候，那么这方面就做的不错了。

#### 5.  渐进式增强
保持渐进式增强作为你前端体系结构的指导原则，那部署就是一个安全的赌注。首先设计和制定核心体验是什么，然后通过一些高级特性为功能强大的浏览器增强用户体验，创造弹性体验感。如果你的网站在比较差的屏幕，浏览器，网络和设备上运行的十分流畅，那在比较好的环境中只会运行更加流畅！

#### 6.  Angular， React， Ember 和 co
喜欢能支持服务器端渲染的框架。在选择框架之前，确保测试服务器端渲染和客户端渲染在移动端的启动时间（因为改变框架之后， 测试性能问题将是比较困难的一件事）。如果你将要使用一个JavaScript框架，确保你的选择是经过[比较](https://www.youtube.com/watch?v=6I_GwgoGm1w)的和[深思熟虑](https://medium.com/@ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.h0r9v08lr)。不同的框架在性能上将会有不同的效果，当然会要求不同的优化策略，所以你必须清楚你将会依赖的框架的所有的细节组成。当构建一个web app， 可以看看 [ PRPL pattern ](https://developers.google.com/web/fundamentals/performance/prpl-pattern/) 和   [application shell architecture](https://developers.google.com/web/updates/2015/11/app-shell).

![PRPL](https://www.smashingmagazine.com/wp-content/uploads/2016/12/app-build-components_dibweb_c_scalew_1408-opt.png)

*PRPL 表示推送关键资源， 渲染初始路由， 预缓存剩余路由 和  按需懒加载剩余路由.*

![ application shell ](https://www.smashingmagazine.com/wp-content/uploads/2016/12/appshell-1_o0t8qd_c_scalew_1249-opt.jpg)

*一个应用程序shell，是用最小的HTML， CSS， JavaScript提供一个用户界面*

#### 7. AMP or Instant Articles

取决于你团体的优先级和战略，你或许想要使用 Google 的 [AMP](https://www.ampproject.org/)  或者  Facebook 的  [Instant Articles](https://instantarticles.fb.com/)。没有它们，你也可以实现良好的性能展现。但是 `AMP` 通过免费的 `CDN` ，确实提供稳定的性能方案，而 `Instant Articles` 将会提高在Facebook上的性能表现。当然你也可以构建  [progressive web AMPs](https://www.smashingmagazine.com/2016/12/progressive-web-amps/) 。

#### 8.  选择CDN

根据你拥有多少动态数据，你可以将内容的一部分放到一个[静态站点生成器](https://www.smashingmagazine.com/2015/11/static-website-generators-jekyll-middleman-roots-hugo-review/)上, 推送到CDN上，生成一个静态的资源版本，来减少数据库的请求。你甚至可以选择一个基于CDN的 [静态托管平台](https://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/) ， 使用交互式组件增强你的页面（[JAMStack](https://jamstack.org/)）.

### 构建优化
#### 9.  设置资源优先级
这是一个好的方法让你知道你首先需要解决的是什么。盘点你全部的资源（JavaScript, images, fonts, 第三方脚本和页面中“昂贵”的模块，像是轮播图，复杂的信息图表，多媒体内容），并给它们分组。

建立一个电子表格。对旧版的浏览器定义最基本的核心体验（即 完全可以访问的核心内容），增强哪些功能更强大的浏览器的体验（即 更加丰富的体验）还有 额外的（资源并不需要第一时间全部加载，可以懒加载，像是web fonts，不必要的样式，轮播图脚本，媒体播放器， 社交媒体按钮， 大图片）。我们发布过一篇文章 " [Improving Smashing Magazine’s Performance](https://www.smashingmagazine.com/2014/09/improving-smashing-magazine-performance-case-study/) ", 里面讨论了这个优化方法的一些细节。

#### 10. 使用 “`cutting-the-mustard`” 技术

使用 [cutting-the-mustard technique](http://responsivenews.co.uk/post/18948466399/cutting-the-mustard) 向旧版浏览器传递核心体验，向现代浏览器传递增强之后的体验方案。严格加载你的资源： 立即加载核心体验的代码，把增强部分加入到 `DomContentLoaded` 事件中，把 附加部分加入到 `load` 事件中。

值得注意的是该技术可以从浏览器版本推断设备能力的强弱，但是现在我们不能再这么干了。举个例子，廉价的安卓手机在发展中国家主要运行Chrome，虽然这些设备只拥有有限的内存和 CPU 能力，但也会使用 `cut the mustard` 技术。注意，当我们有没有别的选择时，使用该技术的局限性会越来越大。

#### 11. 考虑微优化和渐进式启动

有些app在开始渲染页面之前需要先初始化app，可以渲染[骨架页面](https://twitter.com/lukew/status/665288063195594752)去代替加载指示器。因为大多数的性能问题源于启动app的初始解析时间，所以需要找到一些模块和技术去加速初始渲染的时间（ex：[tree-shaking](https://medium.com/@richavyas/aha-moments-from-ngconf-2016-part-1-angular-2-0-compile-cycle-6f462f68632e#.8b9afnsub) and [code-splitting](https://webpack.github.io/docs/code-splitting.html)）。也可以，使用[预解析器](https://www.lucidchart.com/techblog/2016/09/26/improving-angular-2-load-times/)将客户端渲染的负担分担到服务端，快速产生解析结果。最后，使用 [ Optimize.js](https://github.com/nolanlawson/optimize-js)包装急需调用的函数来加快初始加载（虽然，现在这点 [不再是必须](https://twitter.com/tverwaes/status/809788255243739136) 的了）。

![Progressive booting](https://www.smashingmagazine.com/wp-content/uploads/2016/12/fmp-and-tti-opt.jpeg)

*[渐进式启动](https://aerotwist.com/blog/when-everything-is-important-nothing-is/)指的是使用服务器端渲染去得到一个快速的 `first meaningful paint` ,也包括使用一些最小的JavaScript脚本去让 ` time-to-interactive` 时间接近 ` first meaningful paint` 时间。*

客户端渲染 or 服务器端渲染？不管什么场景，我么的目标都是建立[渐进式启动](https://aerotwist.com/blog/when-everything-is-important-nothing-is/)方案：使用服务器端渲染去得到一个理想的 ` first meaningful paint` 时间，也包括使用一些最小的JavaScript脚本去让 ` time-to-interactive` 时间接近 ` first meaningful paint` 时间。我们也可以在需求或者时间允许的情况下，启动一些app非必要的部分。不幸的是，正如[Paul Lewis 注意到的](https://aerotwist.com/blog/when-everything-is-important-nothing-is/#which-to-use-progressive-booting)，框架通常没有优化的概念，这些都抛给了开发者。因此渐进式启动对于大部分的库和框架来说是很难实行的。如果你有时间和资源，使用这个方案去促进性能优化。


#### 12. 正确设置HTTP cache头部
再次检查一遍 `expires`, `cache-control`, `max-age` 和其他 HTTP cache 头部事都设置正确吗。通常，资源应该是可缓存的不管是短时间的（如果它们很可能改变），还是无限期的（如果它们是静态的）——你可以在需要更新的时候， 改变 URL 中它们的版本即可。

如果可能， 使用 `Cache-control: immutable`， 该头部为被打上指纹的静态资源设计，避免资源被重新验证（截至 2016年12月，只有 [FireFox 在 HTTPS 中支持](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) ）。你也可以使用 [Heroku 的 HTTP 缓存头部](https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers)，Jake Archibald 的 [ "Caching Best Practices" ](https://jakearchibald.com/2016/caching-best-practices/)，以及  Ilya Grigorik 的 [HTTP caching primer](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en) 作为指导。

#### 13. 限制第三方库和异步加载的JavaScript

当用户请求一个界面， 浏览器提取 HTML 文档创建 DOM 树，然后提取 CSS 样式表创建 CSSOM 树， 最后通过匹配 DOM 树上的节点和 CSSOM 树上对应的节点合并生成一棵渲染树。如果途中有任何的 JavaScript 需要执行， 浏览器会停止渲染直到该 JavaScript 执行完毕， 因此延缓页面的渲染（阻塞 DOM 构建）。作为开发者，我们必须明确的告诉浏览器不要再等待了，应当抓紧渲染页面。解决方案就是设置为 scripts 设置 `defer` 和 `async` 属性。

#### 14. 正确的图片优化
尽可能的使用 `srcset`， `sizes` 和 `<picture>` 标签来实现 [响应式图片](https://www.smashingmagazine.com/2014/05/responsive-images-done-right-guide-picture-srcset/)。你也可以在 `<picture>` 标签和 一张JPEG图片作为后备（ Andreas Bovens的 [ code snippet](https://dev.opera.com/articles/responsive-images/#different-image-types-use-case)）来加载[ WebP 格式](https://www.smashingmagazine.com/2015/10/webp-images-and-performance/)图片。
或者使用 `Accrpt` 头部来和服务器交流。`Sketch ` 支持 WebP格式， WebP图片在Photoshop中可以使用 [ WebP plugin for Photoshop](http://telegraphics.com.au/sw/product/WebPFormat#webpformat)  来导出。[Other options are available](https://developers.google.com/speed/webp/docs/using)

![](https://www.smashingmagazine.com/wp-content/uploads/2016/12/responsive-image-breakpoints-generator-750w-opt.jpeg)

*[响应式图片断点发生器](http://www.responsivebreakpoints.com/) 可以自动化图像和标记的生成*

你也可以使用  [client hints](https://www.smashingmagazine.com/2016/01/leaner-responsive-images-client-hints/) , 目前还在获得 [浏览器的支持](http://caniuse.com/#search=client-hints) 。没有足够的资源来支持响应式图片的复杂标记？使用 [ Responsive Image Breakpoints Generator ](http://www.responsivebreakpoints.com/) 或者像是[Cloudinary](http://cloudinary.com/documentation/api_and_access_identifiers)这样的服务来自动化图片的优化。此外，在许多情况下，单独使用 `srcset` 或 `sizes` 将会收获显著。 在Smashing杂志中，我们使用 后缀`-opt` 作为图像名称 - 例如， `brotli-compression-opt.png`, 这样只要图像包含这样的后缀，团队中的每个人都知道该图像被优化过了。


#### 15. 让图像优化提高到下一个水平
当在你着手的一个登录页面中，非常紧急的需要一个特定的图像加载的足够的快，这时候你需要确保 JPEGs 通过 [ mozJPEG](https://github.com/mozilla/mozjpeg) （mozJPEG可以提高图片的初始渲染时间，通过操纵扫描级别）来优化 和 压缩，PNG 使用 [Pingo](http://css-ig.net/pingo) , GIF 使用 [ Lossy GIF](https://kornel.ski/lossygif), SVG 使用 [SVGOMG](https://jakearchibald.github.io/svgomg/)。模糊图片不必要的部分（通过应用高斯模糊过滤它们）来减少文件的体积，最终你甚至可以通过着手删除颜色或用黑白呈现图片进一步减少体积。对于背景图片，从Photoshop导出时候减少 0 ~ 10% 的质量也是完全可以接受的。

还不够？那好，也可以通过[multiple](http://csswizardry.com/2016/10/improving-perceived-performance-with-multiple-background-images/) [background](https://jmperezperez.com/medium-image-progressive-loading-placeholder/) [images](https://manu.ninja/dominant-colors-for-lazy-loading-images#tiny-thumbnails) [technique](https://css-tricks.com/the-blur-up-technique-for-loading-background-images/)（这里面每个单词都是一个链接）来提高图像的感觉性能。


#### 16. web fonts 优化

你是用的web fonts很可能包含未使用的字形和额外的功能。如果你用的是 open-source fonts ，你可以向你的类型产生工厂要求一个web fonts子集或者自己[产生一个](https://www.fontsquirrel.com/tools/webfont-generator)来减少文件的体积。能支持WOFF2最好，对不支持的浏览器你也可以使用 WOFF 和OTF 作为降级处理的方案。另外，从Zach Leatherman’s [Comprehensive Guide to Font-Loading Strategies](https://www.zachleat.com/web/comprehensive-webfonts/) 方案 和 [service worker](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjB26L3i4jRAhVnxFQKHQ1RAB4QFggcMAA&url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FService_Worker_API&usg=AFQjCNGcFYqcUoZIpTlw41JzGxE8aGJntw&sig2=HCdwMGD6vwAe8s0o2SAzFw)来永久缓存字体，来选择一种方案。需要快速的效果？Pixel Ambacht 有一个[快速的教程和案例分析](https://pixelambacht.nl/2016/font-awesome-fixed/)去获取指定的字体。

![](https://www.smashingmagazine.com/wp-content/uploads/2016/12/zach-web-fonts_c8nq74_c_scalew_1528-opt.png)

*Zach Leatherman’s Comprehensive Guide to Font-Loading Strategies 为web fonts交付提供了十几个的选项*

如果你不能从自己的服务上使用字体，而是依赖第三方，那就确保使用[ Web Font Loader](https://github.com/typekit/webfontloader)。 [FOUT 比 FOIT 好](https://www.filamentgroup.com/lab/font-events.html); 降级处理中，首先渲染文本，后异步加载字体——你也可以使用 [loadCSS](https://github.com/filamentgroup/loadCSS)。
你也应该[远离本地安装的系统字体](https://www.smashingmagazine.com/2015/11/using-system-ui-fonts-practical-guide/)。


#### 17. 快速推送 critical CSS 样式

为了确保浏览器尽可能快的渲染你的页面，收集渲染页面第一个可见部分需的CSS（“critical CSS” or  “above-the-fold CSS”）以及把他添加到 `<head>` 标签的中来减少请求往返 ，已经变成通常做法。因为在 TCP 慢启动阶段交换的数据包大小有限制，所以你对于 critical CSS 大小的预算是 大约 14 KB。如果超过了这个预算，浏览器需要额外的 HTTP 往返去获取 critical CSS 样式。[CriticalCSS](https://github.com/filamentgroup/criticalCSS) 和 [Critical](https://github.com/addyosmani/critical) 可以确保你在预算之内。在每一个你使用的模版当中你都应该去做这件事。如果可能， 考虑使用 [conditional inlining approach](https://www.filamentgroup.com/lab/performance-rwd.html) ，其已被 the Filament Group 使用。

在 HTTP/2中，为了避免一个产生臃肿的HTML文件, critical CSS应该被存储在一个分离的CSS 文件中并通过服务器推送。但是服务器端推送支持并不一致，而且还有一些还存放方面的问题（查看  [Hooman Beheshti’s presentation](http://www.slideshare.net/Fastly/http2-what-no-one-is-telling-you)）。事实上，这影响是负面的，会膨胀网络的缓冲区，导致文档当中真正的帧无法被递送。因为 TCP 的慢启动，服务器端推送 [在热连接上更加高效](https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit)。 记住，`cache-digest` 这个高速缓存的新规范将会否定手动创建 `"cache-aware"` 服务的需求。

#### 18.  使用 tree-shaking 和 code-splitting 减少有效负载
[tree-shaking](https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf) 是一种，通过只加载生产中确实被使用的代码，来整理你构建过程的方法。你可以使用 [Webpack2中清除未使用导出](http://www.2ality.com/2015/12/webpack-tree-shaking.html), 也可以使用[UnCSS](https://github.com/giakki/uncss) 或者 [Helium](https://github.com/geuis/helium-css) 去删除未使用CSS样式。另外， 你可能会考虑怎么去 书写 [高效的 CSS 选择器](http://csswizardry.com/2011/09/writing-efficient-css-selectors/) 或是怎么[避免 冗长 低效的样式](https://benfrain.com/css-performance-revisited-selectors-bloat-expensive-styles/)。

[Code-splitting ](https://webpack.github.io/docs/code-splitting.html) 是另一种Webpack特性，可以基于“chunks”分割你的代码然后按需加载这些代码块。一旦你在你的代码中确定了分割点，Webpack会全全负责这些依赖关系和输出文件。在应用发送请求的时候，这样基本上确保初始的下载足够小并且实现按需加载。

值得注意的是相比于 Browserify 输出结果  [ Rollup](http://rollupjs.org/)展现的更加优秀。当使用 Rollup时，我们会想要查看 [ Rollupify](https://github.com/nolanlawson/rollupify)，它可以转化 ECMAScript 2015 modules 为一个大的 CommonJS module——因为取决于打包工具和模块加载系统的选择，小的模块会有[令人惊讶的高性能开销](https://nolanlawson.com/2016/08/15/the-cost-of-small-modules/)。

#### 19. 提高渲染性能


